# TTS Reader 安装包极限压缩：踩坑与经验总结

在这几次连续的自动化管线修复与发布（v0.3.1 - v0.3.7）中，我们对 TTS Reader 的可执行文件进行了“外科手术级别”的体积精简，最终成功将近 100MB 的重型应用压缩到了 16MB 左右。但在这个过程中，我们也经历了多次云端报错和本地运行崩溃。

为了让后续接手代码的 AI Agent 开发者以及非技术背景的用户也能明白这期间发生了什么，特将核心踩坑经验做个复盘。

## 核心目标：从 100MB 到 16MB 的“瘦身魔术”

让安装包变小，我们用了两把锋利的手术刀：
1. **UPX 无损压缩**：在云端自动化打包的最后一步，利用 UPX 将生成的 EXE 可执行文件进行底层二进制级别的挤压，体积直接砍半。
2. **PyInstaller 白名单过滤策略**：Python 被称为自带“电池”的语言（自带大量标准底层包）。默认打包时，PyInstaller 为图稳定，会把一切你“可能用到”的包全带上。我们主动重写了 `.spec` 构建配置，将其不需要的重型计算包强制剔除。

## 踩坑实录：我们经历了哪些阻断？

### 坑 1：编译服务器找不到你的配置（v0.3.4 的教训）
- **现象**：本地测试全部完美，一推到 GitHub 上打包就直接报错：“`tts-reader-uia.spec` not found”。
- **原因**：为了让源码仓库干净纯粹，我们曾经在项目初始化时于 `.gitignore` 声明了忽略所有的 `*.spec`。这导致我们包含所有极限压缩策略的心血文件根本没有传到云端。云端服务器面对缺失的图纸陷入了停滞。
- **解决经验**：对于极其定制化的环境构建文件，必须通过类似于 `git add -f` 这样带有强制标识的命令去将其收录到版本库里。

### 坑 2：“硬编码”导致的刻舟求剑（v0.3.5 的教训）
- **现象**：虽然配置文件传上去了，但云端服务器仍然报错找不到关键的内部 `.dll` 模块。
- **原因**：初期生成的 `.spec` 里面，各种 dll 组件的物理硬盘路径被死板地写成了类似 `D:\code\...\.venv\...` 这种完全属于某台私人电脑的绝对硬盘路径。云端分配的 Windows 容器显然不具备这一特殊的深层级目录。
- **解决经验**：所有的构建依赖抓取机制，都应使用动态反射（`os.path.join(os.path.dirname(__file__))`），让打包工具在现场动态算出依赖应该身处何处。

### 坑 3：用力过猛，把大动脉切断了（v0.3.6 的噩梦）
- **现象**：我们终于利用极端手段打出了体积不到 14MB 的绝美文件，云端流水线显示出了一片表示成功的绿海。然而兴奋地下载下来双击时，却瞬间弹红框报错：“`No module named 'zipfile'`”。
- **原因**：在这套剔除名单中，我们过于激进。我们想当然地认为该工具仅仅是在捕获文字与朗读，不涉及大文件的压缩下载，也就把包含解压模块 `zipfile` 和联网底座 `urllib` 在内的数个标准库一同踢掉以节省那一两兆体积。
- **但是**：像 PyInstaller 打出来的单体包，其程序“点开”时，启动器第一步就是用 `zipfile` 等基础核心去解开内嵌在文件末尾的加密模块压缩包！抛头颅洒热血式地把这些底层生存基石丢弃，导致程序连睁开眼睛启动运行的权利都没了。
- **解决经验**：千万不要为了蝇头小利去挑战底层架构赖以生存的基础功能集（例如网络通信、基础解压压缩、跨进程调度等）。剔除大刀只能重重砍在体积变异且极度特定的运算库（如 `numpy` 等大型数学引擎）上。最后将这批关键包补回，体积定格于极度健康的 **16MB**，换取了 100% 的运行稳定性。

## 总结：留给未来维护者的黄金准则
如果你是在未来接手该项目的工程师或编程 Agent，并继续在此基础进行开发：
1. **本地先行测试法（防翻车核心准则）**：永远不要盲目相信“代码没动、只动了配置打包”就能高枕无忧。在推送 `v*` 打标签触发云端 GitHub Actions 之前，**必须**在本地执行以下三步走：
   - 第一步（验证配置）：本地运行 `pyinstaller --clean ... tts-reader-uia.spec` 验证依赖包找齐。
   - 第二步（冷跑测试）：进入本地 `dist\` 目录，双击或者用 Terminal 唤起生成的 `.exe`。
   - 第三步（端到端冒烟）：使用快捷键或 `smoke_test.ps1` 进行一次完整的截图发声链路，确保运行时 Hook 没有缺失关键内建模块（比如刚才的 `zipfile` 崩溃或者缺 dll）。
2. **云端无意识**：由于涉及极其繁杂的系统级 Hook（尤其是原生 TTS 引擎、原生 WinRT OCR 截屏），一切针对性能的底层调试绝不可抱侥幸心理，不能因为本地能 `python src/main.py` 跑通就直接推上云打包。
3. **引入库时的洁癖**：每引入一个新的第三方库，都要首先审视它的体量。尽量使用非常纯粹的基于 Python Built-in 完成的超轻量包，严禁为了极其细微的功能引入沉重的第三方生态引擎链，以免几十兆的心血化为泡影。
